"""
Item-Item Collaborative Filtering Model.

This model recommends items based on item-to-item cosine similarity.
It's a simple but effective baseline that works well for smaller catalogs.

How it works:
1. Each item is represented by the users who interacted with it
2. Cosine similarity is computed between all item pairs
3. Recommendations are generated by aggregating similarities to a user's history

Usage:
    from src.models.item_item import ItemItemRecommender

    model = ItemItemRecommender(k_neighbors=100)
    model.fit(interaction_matrix)

    # Get recommendations for a user
    recommendations = model.recommend(user_idx=0, n=10)

    # Get similar items
    similar = model.similar_items(item_idx=42, n=10)
"""

import logging
from typing import Optional

import numpy as np
from scipy.sparse import csr_matrix
from sklearn.metrics.pairwise import cosine_similarity

from src.models.base import BaseRecommender

logger = logging.getLogger(__name__)


class ItemItemRecommender(BaseRecommender):
    """Item-Item Collaborative Filtering using Cosine Similarity.

    This model computes pairwise cosine similarity between items based on
    their user interaction patterns. Recommendations are generated by
    aggregating similarity scores across a user's interaction history.

    Attributes:
        k_neighbors: Number of similar items to consider per item.
                    Set to None to use all items (full similarity matrix).
        min_similarity: Minimum similarity threshold. Pairs below this
                       are set to zero to reduce noise.
        similarity_matrix_: The computed item-item similarity matrix (set after fit).
        interaction_matrix_: The training interaction matrix (set after fit).
    """

    def __init__(
        self,
        k_neighbors: Optional[int] = 100,
        min_similarity: float = 0.0,
        name: str = "ItemItemRecommender",
    ):
        """Initialize the Item-Item recommender.

        Args:
            k_neighbors: Keep only top-K similar items per item.
                        Set to None to keep all similarities.
            min_similarity: Minimum similarity to keep (0.0 to 1.0).
            name: Human-readable name for the model.
        """
        super().__init__(name=name)
        self.k_neighbors = k_neighbors
        self.min_similarity = min_similarity
        # These are set during fit() - using trailing underscore convention
        # to indicate they're set after fitting (sklearn convention)
        self.similarity_matrix_: np.ndarray
        self.interaction_matrix_: csr_matrix

    def fit(
        self,
        interaction_matrix: csr_matrix,
        show_progress: bool = True,
    ) -> None:
        """Compute item-item similarity matrix.

        Args:
            interaction_matrix: Sparse matrix of shape (n_users, n_items)
            show_progress: Whether to log progress
        """
        self._n_users, self._n_items = interaction_matrix.shape
        self.interaction_matrix_ = interaction_matrix

        if show_progress:
            logger.info(f"Computing item-item similarity for {self.n_items} items...")

        # Transpose to get item-user matrix (items as rows)
        # Each row is an item's "profile" (which users interacted with it)
        item_user_matrix = interaction_matrix.T  # shape: (n_items, n_users)

        # Compute cosine similarity between all item pairs
        # Result shape: (n_items, n_items)
        similarity: np.ndarray = cosine_similarity(item_user_matrix, dense_output=True)

        # Zero out self-similarity (diagonal)
        np.fill_diagonal(similarity, 0.0)

        # Apply minimum similarity threshold
        if self.min_similarity > 0:
            similarity[similarity < self.min_similarity] = 0.0

        # Keep only top-K neighbors per item (sparsify)
        if self.k_neighbors is not None:
            k = min(self.k_neighbors, self.n_items - 1)
            for i in range(self.n_items):
                row = similarity[i]
                if len(row) > k:
                    top_k_indices = np.argpartition(row, -k)[-k:]
                    mask = np.ones(len(row), dtype=bool)
                    mask[top_k_indices] = False
                    similarity[i, mask] = 0.0

        self.similarity_matrix_ = similarity
        self.is_fitted = True

        if show_progress:
            n_nonzero = np.count_nonzero(self.similarity_matrix_)
            density = n_nonzero / (self.n_items**2) * 100
            logger.info(
                f"Similarity matrix computed. "
                f"Non-zero entries: {n_nonzero:,} ({density:.2f}%)"
            )

    def recommend(
        self,
        user_idx: int,
        n: int = 10,
        filter_already_liked: bool = True,
        filter_items: Optional[set[int]] = None,
        items_to_score: Optional[np.ndarray] = None,
    ) -> list[tuple[int, float]]:
        """Generate recommendations for a user.

        Recommendations are based on items similar to what the user has
        already interacted with. The score for each candidate item is the
        sum of its similarities to the user's historical items.

        Args:
            user_idx: Matrix index of the user
            n: Number of recommendations to return
            filter_already_liked: Exclude items the user has interacted with
            filter_items: Additional item indices to exclude
            items_to_score: Only score these items (if None, score all)

        Returns:
            List of (item_idx, score) tuples, sorted by score descending
        """
        self._validate_user_idx(user_idx)

        # Get items this user has interacted with
        user_interactions = self.interaction_matrix_[user_idx].toarray().flatten()
        liked_items = np.where(user_interactions > 0)[0]

        if len(liked_items) == 0:
            logger.debug(f"User {user_idx} has no interactions (cold start)")
            return []

        # Score = sum of similarities to items user has liked
        scores: np.ndarray = self.similarity_matrix_[liked_items].sum(axis=0)

        # Build exclusion mask
        exclude_mask = np.zeros(self.n_items, dtype=bool)

        if filter_already_liked:
            exclude_mask[liked_items] = True

        if filter_items:
            exclude_mask[list(filter_items)] = True

        # Apply exclusion
        scores[exclude_mask] = -np.inf

        # If only scoring specific items, mask others
        if items_to_score is not None:
            score_mask = np.ones(self.n_items, dtype=bool)
            score_mask[items_to_score] = False
            scores[score_mask] = -np.inf

        # Get top-N items
        top_indices = np.argsort(scores)[::-1][:n]

        # Filter out -inf scores (excluded items)
        recommendations = [
            (int(idx), float(scores[idx]))
            for idx in top_indices
            if scores[idx] > -np.inf
        ]

        return recommendations

    def similar_items(
        self,
        item_idx: int,
        n: int = 10,
    ) -> list[tuple[int, float]]:
        """Find items most similar to a given item.

        Args:
            item_idx: Matrix index of the query item
            n: Number of similar items to return

        Returns:
            List of (item_idx, similarity_score) tuples, sorted descending
        """
        self._validate_item_idx(item_idx)

        similarities = self.similarity_matrix_[item_idx]
        top_indices = np.argsort(similarities)[::-1][:n]

        similar = [
            (int(idx), float(similarities[idx]))
            for idx in top_indices
            if similarities[idx] > 0
        ]

        return similar

    def get_params(self) -> dict:
        """Get model hyperparameters for logging."""
        return {
            "name": self.name,
            "k_neighbors": self.k_neighbors,
            "min_similarity": self.min_similarity,
        }

    def get_similarity(self, item_idx_a: int, item_idx_b: int) -> float:
        """Get similarity between two specific items.

        Args:
            item_idx_a: First item index
            item_idx_b: Second item index

        Returns:
            Cosine similarity between the items
        """
        self._validate_item_idx(item_idx_a)
        self._validate_item_idx(item_idx_b)

        return float(self.similarity_matrix_[item_idx_a, item_idx_b])
